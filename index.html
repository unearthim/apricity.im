<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- SEO Meta Tags -->
    <title>Apricity: An Interactive Artwork</title>
    <meta name="description" content="A generative artwork exploring 'apricity' - the warmth of the winter sun. Watch as a low sun brings life to a cold landscape.">
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        /* Use Inter font */
        body {
            font-family: 'Inter', sans-serif;
        }
        
        /* Make html and body take full screen, remove margin/padding */
        html, body {
            width: 100vw;
            height: 100vh;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent scrollbars */
        }

        /* Canvas should be a block element */
        #artCanvas {
            touch-action: none; /* Disable panning/zooming on touch */
            display: block; /* Remove any default spacing */
        }
        /* Fallback font for Tailwind */
        .font-sans {
            font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
        }
    </style>
</head>
<body class="bg-gray-900">

    <!-- The Interactive Artwork -->
    <!-- This main element will be the parent for the canvas -->
    <main class="w-screen h-screen">
        <canvas id="artCanvas"></canvas>
    </main>

    <!-- REMOVED: Instructions Overlay -->

    <script type="module">
        // --- Canvas and Context Setup ---
        const canvas = document.getElementById('artCanvas');
        const ctx = canvas.getContext('2d');

        // --- Off-screen canvas for the static background ---
        const bgCanvas = document.createElement('canvas');
        const bgCtx = bgCanvas.getContext('2d');

        // --- State ---
        let width, height;
        
        // --- Generative State ---
        let sun = { x: 0, y: 0, radius: 50 };
        let trees = [];
        let birds = []; // NEW: Array to hold all active birds
        let startTime = Date.now();
        const DAY_DURATION = 600000; // 10 minutes (10 * 60 * 1000 ms)
        const snowLevel = 0.8; // 80% down the screen
        
        // --- Helper Function ---
        /**
         * Linearly interpolates between two values
         */
        function lerp(start, end, amt) {
            return (1 - amt) * start + amt * end;
        }

        // --- NEW: Bird Class ---
        /**
         * Represents a simple bird particle
         */
        class Bird {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                // Random upward and outward velocity
                this.vx = (Math.random() - 0.5) * 2.5;
                this.vy = -Math.random() * 1.5 - 1.5; // Always fly up
                this.opacity = 1.0;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.opacity -= 0.01; // Fade out as they fly
            }

            draw(ctx) {
                ctx.beginPath();
                // Draw a simple "v" or arc shape
                ctx.arc(this.x, this.y, 3, 0.5 * Math.PI, 1.5 * Math.PI);
                ctx.strokeStyle = `rgba(50, 50, 50, ${this.opacity})`;
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // Check if bird is off-screen or faded
            isGone() {
                return this.opacity <= 0 || this.y < -10 || this.x < -10 || this.x > width + 10;
            }
        }


        // --- Tree Class ---
        /**
         * Represents a dynamic, recursive tree that can change color
         */
        class Tree {
            constructor(x, y, len, angle, branchWidth, coldHSL, warmHSL) {
                this.x = x;
                this.y = y;
                this.len = len;
                this.angle = angle;
                this.branchWidth = branchWidth;
                
                this.coldHSL = coldHSL; // { h, s, l }
                this.warmHSL = warmHSL; // { h, s, l }
                
                this.currentWarmth = 0; // 0 (cold) to 1 (warm)
                this.warmthRadius = 250; // How close the sun needs to be to warm it

                // NEW: Pre-calculate all random values so the tree shape is static
                this.randomValues = [];
                this.precalculateRandoms(10); // Max depth of 10
            }

            /**
             * NEW: Runs once to generate all random values for branches
             */
            precalculateRandoms(maxDepth) {
                // We need random values for each potential branch at each depth
                for (let i = 0; i < maxDepth; i++) {
                    this.randomValues.push({
                        angle1: Math.random() * 20 + 15,          // Main branch 1 angle
                        angle2: -(Math.random() * 20 + 15),       // Main branch 2 angle
                        hasThirdBranch: Math.random() > 0.3,      // Chance of a 3rd, smaller branch
                        thirdBranchAngle: Math.random() * 10 - 5, // 3rd branch angle
                        thirdBranchLenMult: Math.random() * 0.5 + 0.3 // 3rd branch position
                    });
                }
            }

            /**
             * NEW: Returns the bounding box for click detection
             */
            getBoundingBox() {
                // A simplified box around the main trunk and lower branches
                const boxHeight = this.len * 1.2;
                const boxWidth = this.len; 
                return {
                    x: this.x - boxWidth / 2,
                    y: this.y - boxHeight, // y is at the base, so go up
                    width: boxWidth,
                    height: boxHeight
                };
            }

            /**
             * NEW: Spawns a flock of birds from this tree
             */
            spawnBirds() {
                const flockSize = 5 + Math.floor(Math.random() * 5); // 5-9 birds
                for (let i = 0; i < flockSize; i++) {
                    // Start from the upper-middle part of the tree
                    const startX = this.x + (Math.random() - 0.5) * 40;
                    const startY = (this.y - this.len * 0.7) + (Math.random() - 0.5) * 20;
                    birds.push(new Bird(startX, startY));
                }
            }

            /**
             * Update the tree's warmth based on the sun's position
             */
            update(sunX, sunY) {
                // Calculate distance from the base of the tree to the sun
                const dist = Math.hypot(this.x - sunX, (this.y - this.len * 0.5) - sunY);
                
                let targetWarmth = 0;
                if (dist < this.warmthRadius) {
                    // The closer the sun, the warmer it gets (1.0 at 0 distance, 0.0 at max distance)
                    targetWarmth = 1.0 - (dist / this.warmthRadius);
                }

                // Smoothly ease the current warmth towards the target warmth
                this.currentWarmth += (targetWarmth - this.currentWarmth) * 0.02;
            }

            /**
             * Draw the tree by starting the recursive drawBranch function
             */
            draw(ctx) {
                // Interpolate H, S, and L values based on current warmth
                const h = lerp(this.coldHSL.h, this.warmHSL.h, this.currentWarmth);
                const s = lerp(this.coldHSL.s, this.warmHSL.s, this.currentWarmth);
                const l = lerp(this.coldHSL.l, this.warmHSL.l, this.currentWarmth);
                
                const color = `hsl(${h}, ${s}%, ${l}%)`;
                
                // Start the recursive drawing process
                this.drawBranch(ctx, this.x, this.y, this.len, this.angle, this.branchWidth, color, 0);
            }

            /**
             * Recursively draws a branch of the tree
             */
            drawBranch(c, startX, startY, len, angle, branchWidth, color, depth) {
                c.beginPath();
                c.save();
                c.strokeStyle = color;
                c.lineWidth = branchWidth;
                c.translate(startX, startY);
                c.rotate(angle * Math.PI / 180);
                c.moveTo(0, 0);
                c.lineTo(0, -len); // Draw "up" in the new coordinate system
                c.stroke();

                if (len < 10 || depth > 8) {
                    c.restore();
                    return;
                }
                
                // Get PRE-CALCULATED random values for this depth
                const rand = this.randomValues[depth]; 
                if (!rand) { // Safety check
                    c.restore();
                    return;
                }

                const newLen = len * 0.75;
                const newWidth = branchWidth * 0.7;

                // Recursive calls for branches using PRE-CALCULATED values
                c.beginPath(); // Fix for stroke bleeding
                this.drawBranch(c, 0, -len, newLen, rand.angle1, newWidth, color, depth + 1);
                c.beginPath();
                this.drawBranch(c, 0, -len, newLen, rand.angle2, newWidth, color, depth + 1);
                if (rand.hasThirdBranch) {
                     c.beginPath();
                     this.drawBranch(c, 0, -len * rand.thirdBranchLenMult , len * 0.5, rand.thirdBranchAngle, newWidth * 0.9, color, depth + 1);
                }

                c.restore();
            }
        }

        // --- Procedural Generation ---

        /**
         * NEW: Spawns a flock of birds from a specific coordinate
         */
        function spawnBirdsAt(x, y) {
            const flockSize = 3 + Math.floor(Math.random() * 3); // 3-5 birds
            for (let i = 0; i < flockSize; i++) {
                // Start from the click location, with a tiny bit of spread
                const startX = x + (Math.random() - 0.5) * 20;
                const startY = y + (Math.random() - 0.5) * 20;
                birds.push(new Bird(startX, startY));
            }
        }

        /**
         * Draws the static cold background (sky, snow, ground) onto the bgCanvas
         */
        function drawBackground() {
            // Set background canvas size
            bgCanvas.width = width;
            bgCanvas.height = height;

            // 1. Draw the cold sky
            const skyGradient = bgCtx.createLinearGradient(0, 0, 0, height);
            skyGradient.addColorStop(0, '#2d3748'); // Dark slate
            skyGradient.addColorStop(0.7, '#718096'); // Gray
            skyGradient.addColorStop(1, '#a0aec0'); // Lighter gray
            bgCtx.fillStyle = skyGradient;
            bgCtx.fillRect(0, 0, width, height);

            // 2. Draw dark ground underneath the snow level
            const groundLevel = height * snowLevel;
            const groundGradient = bgCtx.createLinearGradient(0, groundLevel, 0, height);
            groundGradient.addColorStop(0, '#4a3832'); // Dark earth brown
            groundGradient.addColorStop(1, '#2d201c'); // Darker brown
            bgCtx.fillStyle = groundGradient;
            bgCtx.fillRect(0, groundLevel, width, height - groundLevel); // Fill from snow level down

            // 3. Draw the snow ON TOP of the ground
            bgCtx.fillStyle = '#f7fafc'; // Off-white
            bgCtx.beginPath();
            bgCtx.moveTo(0, groundLevel);
            // Simple hilly terrain
            bgCtx.quadraticCurveTo(width * 0.25, groundLevel - 20, width * 0.5, groundLevel - 5);
            bgCtx.quadraticCurveTo(width * 0.75, groundLevel + 10, width, groundLevel - 10);
            bgCtx.lineTo(width, height);
            bgCtx.lineTo(0, height);
            bgCtx.closePath();
            bgCtx.fill();
            
            // NOTE: Trees are no longer drawn here.
        }

        /**
         * Clears and creates the dynamic trees based on screen size
         */
        function createTrees() {
            trees = []; // Clear existing trees
            const groundLevel = height * snowLevel;

            // Define HSL colors
            const cold = { h: 210, s: 15, l: 40 }; // Drab gray-blue
            const warm = { h: 90, s: 20, l: 35 }; // Mossy green-brown

            // Add trees to the array
            trees.push(new Tree(width * 0.2, groundLevel, 90, 0, 10, cold, warm));
            trees.push(new Tree(width * 0.8, groundLevel - 10, 80, 0, 8, cold, warm));
            trees.push(new Tree(width * 0.5, groundLevel - 5, 100, 0, 12, cold, warm));
            trees.push(new Tree(width * 0.35, groundLevel - 2, 70, 0, 7, cold, warm));
            trees.push(new Tree(width * 0.65, groundLevel - 8, 75, 0, 7, cold, warm));
        }

        // --- Event Handlers ---
        
        /**
         * NEW: Handle clicks on the canvas
         */
        function handleClick(event) {
            const clickX = event.clientX;
            const clickY = event.clientY;
            let warmTreeClicked = false; // NEW: Flag to track interaction

            // Check if the click hit a warm tree
            for (const tree of trees) {
                const box = tree.getBoundingBox();
                
                // 1. Check if click is inside the tree's box
                if (clickX > box.x && clickX < box.x + box.width &&
                    clickY > box.y && clickY < box.y + box.height) {
                    
                    // 2. Check if the tree is "warm"
                    if (tree.currentWarmth > 0.4) {
                        tree.spawnBirds();
                        warmTreeClicked = true; // Set the flag
                        break; // Only trigger one tree
                    }
                }
            }

            // NEW: If no warm tree was clicked, spawn birds from the click location
            if (!warmTreeClicked) {
                spawnBirdsAt(clickX, clickY);
            }
        }

        // --- Resize Handler ---
        function resize() {
            const container = canvas.parentElement;
            // The rect of the parent (main) will be the screen size
            const rect = container.getBoundingClientRect();
            width = canvas.width = rect.width;
            height = canvas.height = rect.height;
            
            drawBackground(); // Re-draw the static background
            createTrees(); // Re-create the dynamic trees
        }

        // --- Animation Loop ---
        function animate(timestamp) {
            // 1. Calculate Sun Position
            // const now = timestamp || Date.now(); // OLD BUGGY LINE
            const now = Date.now(); // NEW: Always use wall clock time, ignore timestamp
            
            const elapsed = (now - startTime) % DAY_DURATION;
            const dayProgress = elapsed / DAY_DURATION; // 0.0 to 1.0

            // Sun X: Moves from left to right
            sun.x = dayProgress * (width + 200) - 100; // -100 to width+100
            
            // Sun Y: Moves in a low arc
            // Math.sin(dayProgress * Math.PI) goes from 0 -> 1 -> 0
            
            // OLD BUGGY LINE:
            // This makes it start high, go low (max height at 0.5), and return high
            // sun.y = (height * 0.2) + Math.sin(dayProgress * Math.PI) * (height * 0.7);

            // NEW FIXED LINE:
            // Start at a high Y-value (horizon) and SUBTRACT the sine wave to move UP.
            // This makes it start low, go high (min Y-value at 0.5), and return low.
            const horizonY = height * 0.75; // Just above the snow line
            const arcHeight = height * 0.3; // WAS 0.6 - This is the fix. Lower arc.
            sun.y = horizonY - (Math.sin(dayProgress * Math.PI) * arcHeight);


            // 2. Draw the static background
            ctx.globalCompositeOperation = 'source-over';
            ctx.drawImage(bgCanvas, 0, 0);

            // 3. Draw the Sun
            const sunGradient = ctx.createRadialGradient(
                sun.x, sun.y, 0,
                sun.x, sun.y, sun.radius
            );
            sunGradient.addColorStop(0, 'rgba(255, 255, 220, 1)');
            sunGradient.addColorStop(0.5, 'rgba(255, 204, 100, 0.8)');
            sunGradient.addColorStop(1, 'rgba(255, 180, 70, 0)');
            
            ctx.fillStyle = sunGradient;
            ctx.beginPath();
            ctx.arc(sun.x, sun.y, sun.radius, 0, Math.PI * 2);
            ctx.fill();

            // 4. Update and Draw all trees
            trees.forEach(tree => {
                tree.update(sun.x, sun.y);
                tree.draw(ctx);
            });

            // 5. NEW: Update and Draw Birds
            // Loop backwards for safe removal
            for (let i = birds.length - 1; i >= 0; i--) {
                const bird = birds[i];
                bird.update();
                bird.draw(ctx);

                if (bird.isGone()) {
                    birds.splice(i, 1);
                }
            }

            // 6. Request next frame
            requestAnimationFrame(animate);
        }

        // --- Initialization ---
        window.addEventListener('resize', resize);
        window.addEventListener('click', handleClick); // NEW: Add click listener
        resize(); // Initial setup
        startTime = Date.now(); // Reset start time
        // animate(0); // OLD CALL
        animate(); // Start the loop
    </script>

</body>
</html>